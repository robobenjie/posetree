window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "posetree", "modulename": "posetree", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "posetree.pose", "modulename": "posetree.pose", "kind": "module", "doc": "<p><code>posetree</code> is a module for representing and manipulating poses in 3D space. There are two main classes: <code>Pose</code> and <code>PoseTree</code>.</p>\n\n<p>A <code>Pose</code> is an immutable location and orientation in 3D space, relative to a frame (i.e. 1 meter forward in X from the robot base).</p>\n\n<p>A <code>PoseTree</code> is a object that keeps track of frames as they change over time, so that poses can know how to transform themselves into other frames, \nand do math operations with poses in different frames at particular points in time. You will need to subclass PoseTree to hook it up to your robot's\nodometry system.</p>\n"}, {"fullname": "posetree.pose.Pose", "modulename": "posetree.pose", "qualname": "Pose", "kind": "class", "doc": "<p>A Pose is an immutable location and orientation in 3D space.\nA pose is defined with a <code>parent_frame</code> (where to start) and a transform (how to get to the pose from the parent frame).</p>\n\n<p>Note: While a Pose is immutable, the parent frame can (and does!) change over time relative to other frames, meaning that an individual pose can move relative\nto other frames. (For example a pose defined in the \"robot\" frame will conceptually move as the robot moves relative to a 'world'\nframe, even though its position and orientation remain immutably constant.)</p>\n"}, {"fullname": "posetree.pose.Pose.__init__", "modulename": "posetree.pose", "qualname": "Pose.__init__", "kind": "function", "doc": "<p>Create a pose from a transform, frame, and pose tree.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>transform:</strong>  The transform from the frame to the pose.</li>\n<li><strong>parent_frame:</strong>  The frame that the transform is relative to.</li>\n<li><strong>pose_tree:</strong>  The world that the pose exists in.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">transform</span><span class=\"p\">:</span> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Transform</span>,</span><span class=\"param\">\t<span class=\"n\">parent_frame</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">pose_tree</span><span class=\"p\">:</span> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">PoseTree</span></span>)</span>"}, {"fullname": "posetree.pose.Pose.from_position_and_quaternion", "modulename": "posetree.pose", "qualname": "Pose.from_position_and_quaternion", "kind": "function", "doc": "<p>Create a pose from a position and quaternion.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>position:</strong>  The position of the transform.</li>\n<li><strong>quaternion:</strong>  The quaternion of the transform, in xyzw order.</li>\n<li><strong>parent_frame:</strong>  The frame that the transform is relative to.</li>\n<li><strong>pose_tree:</strong>  The world that the pose exists in.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new Pose.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">position</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">quaternion</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">parent_frame</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">pose_tree</span><span class=\"p\">:</span> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">PoseTree</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.from_position_and_rotation", "modulename": "posetree.pose", "qualname": "Pose.from_position_and_rotation", "kind": "function", "doc": "<p>Create a transform from a position and rotatoin.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>position:</strong>  The position of the transform.</li>\n<li><strong>rotation:</strong>  The rotation of the transform.</li>\n<li><strong>parent_frame:</strong>  The frame that the transform is relative to.</li>\n<li><strong>pose_tree:</strong>  The world that the pose exists in.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new Pose.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">position</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">rotation</span><span class=\"p\">:</span> <span class=\"n\">scipy</span><span class=\"o\">.</span><span class=\"n\">spatial</span><span class=\"o\">.</span><span class=\"n\">transform</span><span class=\"o\">.</span><span class=\"n\">_rotation</span><span class=\"o\">.</span><span class=\"n\">Rotation</span>,</span><span class=\"param\">\t<span class=\"n\">parent_frame</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">pose_tree</span><span class=\"p\">:</span> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">PoseTree</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.transform", "modulename": "posetree.pose", "qualname": "Pose.transform", "kind": "variable", "doc": "<p>The transform from the parent frame to the pose.</p>\n", "annotation": ": posetree.pose.Transform"}, {"fullname": "posetree.pose.Pose.position", "modulename": "posetree.pose", "qualname": "Pose.position", "kind": "variable", "doc": "<p>The position of the pose relative to the parent frame.</p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "posetree.pose.Pose.rotation", "modulename": "posetree.pose", "qualname": "Pose.rotation", "kind": "variable", "doc": "<p>The rotation of the pose relative to the parent frame.</p>\n", "annotation": ": scipy.spatial.transform._rotation.Rotation"}, {"fullname": "posetree.pose.Pose.frame", "modulename": "posetree.pose", "qualname": "Pose.frame", "kind": "variable", "doc": "<p>The parent frame of the pose.</p>\n", "annotation": ": str"}, {"fullname": "posetree.pose.Pose.pose_tree", "modulename": "posetree.pose", "qualname": "Pose.pose_tree", "kind": "variable", "doc": "<p>The PoseTree object containing the world that the pose exists in.</p>\n", "annotation": ": posetree.pose.PoseTree"}, {"fullname": "posetree.pose.Pose.x", "modulename": "posetree.pose", "qualname": "Pose.x", "kind": "variable", "doc": "<p>The x coordinate of the position.</p>\n", "annotation": ": float"}, {"fullname": "posetree.pose.Pose.y", "modulename": "posetree.pose", "qualname": "Pose.y", "kind": "variable", "doc": "<p>The y coordinate of the position.</p>\n", "annotation": ": float"}, {"fullname": "posetree.pose.Pose.z", "modulename": "posetree.pose", "qualname": "Pose.z", "kind": "variable", "doc": "<p>The z coordinate of the position.</p>\n", "annotation": ": float"}, {"fullname": "posetree.pose.Pose.x_axis", "modulename": "posetree.pose", "qualname": "Pose.x_axis", "kind": "variable", "doc": "<p>The x axis of the pose.</p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "posetree.pose.Pose.y_axis", "modulename": "posetree.pose", "qualname": "Pose.y_axis", "kind": "variable", "doc": "<p>The y axis of the pose.</p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "posetree.pose.Pose.z_axis", "modulename": "posetree.pose", "qualname": "Pose.z_axis", "kind": "variable", "doc": "<p>The z axis of the pose.</p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "posetree.pose.Pose.in_frame", "modulename": "posetree.pose", "qualname": "Pose.in_frame", "kind": "function", "doc": "<p>Return a new pose representing the same location in space expressed in a different frame.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>new_parent_frame:</strong>  The new frame that the transform is relative to.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new pose with the same transform but in a different frame.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">parent_frame</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">timestamp</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.with_position", "modulename": "posetree.pose", "qualname": "Pose.with_position", "kind": "function", "doc": "<p>Return a new pose with the same rotation but a different location relative to the parent frame.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>position:</strong>  The new location of the pose.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new pose with the same rotation but a different location.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">position</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.with_rotation", "modulename": "posetree.pose", "qualname": "Pose.with_rotation", "kind": "function", "doc": "<p>Return a new pose with the same location but a different rotation.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>rotation:</strong>  The new rotation of the pose.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new pose with the same location but a different rotation.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">rotation</span><span class=\"p\">:</span> <span class=\"n\">scipy</span><span class=\"o\">.</span><span class=\"n\">spatial</span><span class=\"o\">.</span><span class=\"n\">transform</span><span class=\"o\">.</span><span class=\"n\">_rotation</span><span class=\"o\">.</span><span class=\"n\">Rotation</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.with_rotation_matching", "modulename": "posetree.pose", "qualname": "Pose.with_rotation_matching", "kind": "function", "doc": "<p>Return a new pose with the same position but a different orientation, matching another pose.</p>\n\n<p>This method is frame aware, so even if the other pose has a different frame, the rotation will be matched correctly.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>other:</strong>  The pose to match the rotation of.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new pose with the same position but a different orientation.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span><span class=\"p\">:</span> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.with_position_x", "modulename": "posetree.pose", "qualname": "Pose.with_position_x", "kind": "function", "doc": "<p>Return a new pose with the same y and z coordinates but a different x coordinate.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x:</strong>  The new x coordinate of the pose.</li>\n<li><strong>frame:</strong>  The frame that the x coordinate is relative to. If None, the x coordinate is relative to the pose's frame.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new pose with the same y and z coordinates but a different x coordinate.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">frame</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.with_position_y", "modulename": "posetree.pose", "qualname": "Pose.with_position_y", "kind": "function", "doc": "<p>Return a new pose with the same x and z coordinates but a different y coordinate.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>y:</strong>  The new y coordinate of the pose.</li>\n<li><strong>frame:</strong>  The frame that the y coordinate is relative to. If None, the y coordinate is relative to the pose's frame.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new pose with the same x and z coordinates but a different y coordinate.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">frame</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.with_position_z", "modulename": "posetree.pose", "qualname": "Pose.with_position_z", "kind": "function", "doc": "<p>Return a new pose with the same x and y coordinates but a different z coordinate.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>z:</strong>  The new z coordinate of the pose.</li>\n<li><strong>frame:</strong>  The frame that the z coordinate is relative to. If None, the z coordinate is relative to the pose's frame.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new pose with the same x and y coordinates but a different z coordinate.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">z</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">frame</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.apply_transform", "modulename": "posetree.pose", "qualname": "Pose.apply_transform", "kind": "function", "doc": "<p>Return a new pose transformed by a transform.</p>\n\n<p>This method is provided to give compatibility with systems that talk about poses in terms of transforms,\nbut it is usually more readable and debuggable to use a rotate/translate method instead.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>transform:</strong>  The transform to apply.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new pose transformed by a transform.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">transform</span><span class=\"p\">:</span> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Transform</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.translate", "modulename": "posetree.pose", "qualname": "Pose.translate", "kind": "function", "doc": "<p>Return a new pose translated by a vector.</p>\n\n<p>The translation is relative to the basis of the pose being translated (i.e body-fixed) rather than the parent frame.\nThat means that</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">p2</span> <span class=\"o\">=</span> <span class=\"n\">p1</span><span class=\"o\">.</span><span class=\"n\">translate</span><span class=\"p\">((</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n</code></pre>\n</div>\n\n<p>and</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">p2</span> <span class=\"o\">=</span> <span class=\"n\">p1</span><span class=\"o\">.</span><span class=\"n\">in_frame</span><span class=\"p\">(</span><span class=\"s2\">&quot;some_other_frame&quot;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">translate</span><span class=\"p\">((</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">in_frame</span><span class=\"p\">(</span><span class=\"n\">p1</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>are identical, because the parent frame of a pose does not affect its translation.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>translation:</strong>  The vector to translate by.</li>\n<li><strong>frame:</strong>  The frame that the vector is relative to.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new pose translated by a vector.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">translation</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">frame</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.rotate_about_axis", "modulename": "posetree.pose", "qualname": "Pose.rotate_about_axis", "kind": "function", "doc": "<p>Return a new pose rotated about an axis.</p>\n\n<p>This is rotated in the basis of the pose being rotated (i.e body-fixed) rather than the parent frame, and it only\nrotates the orientation. This is <em>not</em> a rotation about the origin, but a change of the orientation of the pose.</p>\n\n<p>If you pass a frame, the axis will be interpreted as being expressed in that frame.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>axis:</strong>  The axis to rotate about.</li>\n<li><strong>angle:</strong>  The angle to rotate by, in radians unless degrees=True.</li>\n<li><strong>degrees:</strong>  Whether the angle is in degrees.</li>\n<li><strong>frame:</strong>  The frame that the axis is relative to. If None, the axis is interpreted in the basis vectors of the pose (not the parent frame).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new pose with the same location but rotated about an axis.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">axis</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">degrees</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">frame</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.rotate_about_x", "modulename": "posetree.pose", "qualname": "Pose.rotate_about_x", "kind": "function", "doc": "<p>Return a new pose rotated about the x axis.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>angle:</strong>  The angle to rotate by, in radians unless degrees=True.</li>\n<li><strong>degrees:</strong>  Whether the angle is in degrees.</li>\n<li><strong>frame:</strong>  The frame that the axis is relative to. If not provided, it will rotate about the x-unit-vector of the pose being rotated.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new pose with the same location but rotated about the x axis.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">degrees</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">frame</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.rotate_about_y", "modulename": "posetree.pose", "qualname": "Pose.rotate_about_y", "kind": "function", "doc": "<p>Return a new pose rotated about the y axis.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>angle:</strong>  The angle to rotate by, in radians unless degrees=True.</li>\n<li><strong>degrees:</strong>  Whether the angle is in degrees.</li>\n<li><strong>frame:</strong>  The frame that the axis is relative to. If not provided, it will rotate about the y-unit-vector of the pose being rotated.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new pose with the same location but rotated about the y axis.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">degrees</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">frame</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.rotate_about_z", "modulename": "posetree.pose", "qualname": "Pose.rotate_about_z", "kind": "function", "doc": "<p>Return a new pose rotated about the z axis.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>angle:</strong>  The angle to rotate by, in radians unless degrees=True.</li>\n<li><strong>degrees:</strong>  Whether the angle is in degrees.</li>\n<li><strong>frame:</strong>  The frame that the axis is relative to. If not provided, it will rotate about the z-unit-vector of the pose being rotated.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new pose with the same location but rotated about the z axis.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">degrees</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">frame</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.point_x_at", "modulename": "posetree.pose", "qualname": "Pose.point_x_at", "kind": "function", "doc": "<p>Return a new pose rotated to point the x axis at a target pose.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>target:</strong>  The target pose to point at.</li>\n<li><strong>fixed_axis:</strong>  An optional axis ('x', 'y' or 'z') to keep fixed. If not provided,\nthe pose will be rotated the minimum rotation to have the axis point at the target pose.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new pose with the same location but rotated to point the x axis at a target pose.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>,</span><span class=\"param\">\t<span class=\"n\">fixed_axis</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.point_y_at", "modulename": "posetree.pose", "qualname": "Pose.point_y_at", "kind": "function", "doc": "<p>Return a new pose rotated to point the y axis at a target pose.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>target:</strong>  The target pose to point at.</li>\n<li><strong>fixed_axis:</strong>  An optional axis ('x', 'y' or 'z') to keep fixed. If not provided,\nthe pose will be rotated the minimum rotation to have the axis point at the target pose.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new pose with the same location but rotated to point the y axis at a target pose.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>,</span><span class=\"param\">\t<span class=\"n\">fixed_axis</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.point_z_at", "modulename": "posetree.pose", "qualname": "Pose.point_z_at", "kind": "function", "doc": "<p>Return a new pose rotated to point the z axis at a target pose.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>target:</strong>  The target pose to point at.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new pose with the same location but rotated to point the z axis at a target pose.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>,</span><span class=\"param\">\t<span class=\"n\">fixed_axis</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.interpolate", "modulename": "posetree.pose", "qualname": "Pose.interpolate", "kind": "function", "doc": "<p>Return a new pose interpolated between two poses, in the frame of the first pose.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>target:</strong>  The target pose to interpolate to.</li>\n<li><strong>alpha:</strong>  The interpolation factor. 0.0 will return the current pose, 1.0 will return\nthe target pose and values in between will return a pose interpolated between the two.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new pose interpolated between two poses.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>, </span><span class=\"param\"><span class=\"n\">alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.distance_to", "modulename": "posetree.pose", "qualname": "Pose.distance_to", "kind": "function", "doc": "<p>Return the cartesian distance between two poses.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>other:</strong>  The other pose.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The distance between two poses.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span><span class=\"p\">:</span> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.angle_to", "modulename": "posetree.pose", "qualname": "Pose.angle_to", "kind": "function", "doc": "<p>Return the angle between two poses' orientations. Ignores position. Will convert to the same frame.</p>\n\n<p>This gives the magnitude of the minimal rotation that will align the two poses.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>target:</strong>  The target pose.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The angle between two poses, in radians.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.angle_about_x_to", "modulename": "posetree.pose", "qualname": "Pose.angle_about_x_to", "kind": "function", "doc": "<p>Return the signed angle between two poses' orientations about the x axis. Ignores position. Will convert to the same frame.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>target:</strong>  The target pose.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The angle between two poses, in radians.</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>ValueError:</strong>  If the rotation is more than 20% out of the expected axis.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.angle_about_y_to", "modulename": "posetree.pose", "qualname": "Pose.angle_about_y_to", "kind": "function", "doc": "<p>Return the signed angle between two poses' orientations about the y axis. Ignores position. Will convert to the same frame.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>target:</strong>  The target pose.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The angle between two poses, in radians.</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>ValueError:</strong>  If the rotation is more than 20% out of the expected axis.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Pose.angle_about_z_to", "modulename": "posetree.pose", "qualname": "Pose.angle_about_z_to", "kind": "function", "doc": "<p>Return the signed angle between two poses' orientations about the z axis. Ignores position. Will convert to the same frame.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>target:</strong>  The target pose.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The angle between two poses, in radians.</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>ValueError:</strong>  If the rotation is more than 20% out of the expected axis.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.PoseTree", "modulename": "posetree.pose", "qualname": "PoseTree", "kind": "class", "doc": "<p>Abstract base class to manage poses and frames.</p>\n\n<p>To hook up this library to your project, you should subclass this class and hook it up to your stream of transforms\nby implementing _get_transform. Usually this will look like adding a callback-subscribe method to your class and storing\nthe transforms between important frames as they come in. If you don't already have a way of interpolating between transforms,\ncheck out ROS's tf2 library. This library is designed to wrap nicely on top of tf2, if you are already using it.</p>\n", "bases": "abc.ABC"}, {"fullname": "posetree.pose.PoseTree.get_transform", "modulename": "posetree.pose", "qualname": "PoseTree.get_transform", "kind": "function", "doc": "<p>Return the transform from the parent frame to the child frame.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">parent_frame</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">child_frame</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">timestamp</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Transform</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.PoseTree.get_pose", "modulename": "posetree.pose", "qualname": "PoseTree.get_pose", "kind": "function", "doc": "<p>Create a pose object from a position, quaternion, and parent frame. Essentially syntactic sugar on top of Pose's constructor.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">position</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">quaternion</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">parent_frame</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.PoseTree.temporary_frame", "modulename": "posetree.pose", "qualname": "PoseTree.temporary_frame", "kind": "function", "doc": "<p>Create a temporary frame from a pose.</p>\n\n<p>This is intended to be used for anonymous frames for doing calculations.</p>\n\n<p>Example 1, find an approach angle that is close to the robot base:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"k\">for</span> <span class=\"n\">theta</span> <span class=\"ow\">in</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">):</span>\n    <span class=\"k\">with</span> <span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">temporary_frame</span><span class=\"p\">(</span><span class=\"n\">target_pose</span><span class=\"o\">.</span><span class=\"n\">rotate_about_z</span><span class=\"p\">(</span><span class=\"n\">theta</span><span class=\"p\">))</span> <span class=\"k\">as</span> <span class=\"n\">approach_frame</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"nb\">abs</span><span class=\"p\">(</span><span class=\"n\">robot_base_pose</span><span class=\"o\">.</span><span class=\"n\">in_frame</span><span class=\"p\">(</span><span class=\"n\">approach_frame</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"o\">&lt;</span> <span class=\"mf\">0.1</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">theta</span>\n</code></pre>\n</div>\n\n<p>Example 2, find a person that is ready to talk to the robot:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"k\">for</span> <span class=\"n\">person</span> <span class=\"ow\">in</span> <span class=\"n\">people</span><span class=\"p\">:</span>\n    <span class=\"k\">with</span> <span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">temporary_frame</span><span class=\"p\">(</span><span class=\"n\">person</span><span class=\"o\">.</span><span class=\"n\">head_pose</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">head_frame</span><span class=\"p\">:</span>\n    <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">robot_base_pose</span><span class=\"o\">.</span><span class=\"n\">in_frame</span><span class=\"p\">(</span><span class=\"n\">head_frame</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">position</span>\n        <span class=\"k\">if</span> <span class=\"nb\">abs</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"o\">&lt;</span> <span class=\"mf\">0.5</span> <span class=\"ow\">and</span> <span class=\"mf\">0.5</span> <span class=\"o\">&lt;</span> <span class=\"n\">x</span> <span class=\"o\">&lt;</span> <span class=\"mf\">1.5</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">person</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pose</span><span class=\"p\">:</span> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.PoseTree.add_frame", "modulename": "posetree.pose", "qualname": "PoseTree.add_frame", "kind": "function", "doc": "<p>Add a static frame to the tree.</p>\n\n<p>Example:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">pose_tree</span><span class=\"o\">.</span><span class=\"n\">add_frame</span><span class=\"p\">(</span><span class=\"n\">table_corner_pose</span><span class=\"p\">,</span> <span class=\"s1\">&#39;table_frame&#39;</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Look at center of table:</span>\n<span class=\"n\">robot</span><span class=\"o\">.</span><span class=\"n\">look_at</span><span class=\"p\">(</span>\n    <span class=\"n\">Pose</span><span class=\"o\">.</span><span class=\"n\">from_position_and_rotation</span><span class=\"p\">(</span>\n        <span class=\"p\">[</span><span class=\"n\">table_size_x</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">tablesize_y_y</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n        <span class=\"n\">Rotation</span><span class=\"o\">.</span><span class=\"n\">identity</span><span class=\"p\">(),</span>\n        <span class=\"s1\">&#39;table_frame&#39;</span><span class=\"p\">))</span>\n</code></pre>\n</div>\n\n<p>Don't use this for scratch frames for doing calculations. Use the temporary_frame context manager instead. This should \nbe used for permanant, human meaningful things like a workspace frame.</p>\n\n<p>This is also not a good solution for frames that are moving, as the frames will not be interpolated to particular timestamps.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pose:</strong>  The pose of the new frame relative to the parent frame.</li>\n<li><strong>name:</strong>  The name of the new frame.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pose</span><span class=\"p\">:</span> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.PoseTree.remove_frame", "modulename": "posetree.pose", "qualname": "PoseTree.remove_frame", "kind": "function", "doc": "<p>Remove a static frame from the tree.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.CustomFramePoseTree", "modulename": "posetree.pose", "qualname": "CustomFramePoseTree", "kind": "class", "doc": "<p>A abstract PoseTree implementation that implements custom frames.</p>\n\n<p>This is useful if your underlying pose structure doesn't support custom frames. You subclass this\nclass and implement the _get_transform method and get full custom frame support. In a pinch you can implement\n_get_transform to raise a NotImplemented error and use 'add frame' but it is not particularly efficient and does\nnot implement interpolation to particular timestamps, which will cause problems if you are getting sensor\ninformation off a moving robot.</p>\n", "bases": "PoseTree, abc.ABC"}, {"fullname": "posetree.pose.CustomFramePoseTree.custom_frames", "modulename": "posetree.pose", "qualname": "CustomFramePoseTree.custom_frames", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "posetree.pose.CustomFramePoseTree.add_frame", "modulename": "posetree.pose", "qualname": "CustomFramePoseTree.add_frame", "kind": "function", "doc": "<p>Add a frame to the tree. This is assumed to be a static frame, and will not be interpolated.</p>\n\n<p>If that frame is already present, this will update the frame to a new pose.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pose:</strong>  The pose of the new frame relative to the parent frame.</li>\n<li><strong>name:</strong>  The name of the new frame.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pose</span><span class=\"p\">:</span> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Pose</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.CustomFramePoseTree.remove_frame", "modulename": "posetree.pose", "qualname": "CustomFramePoseTree.remove_frame", "kind": "function", "doc": "<p>Remove a custom frame from the tree.</p>\n\n<p>This method is idempotent. If the frame is not present, it will do nothing.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.CustomFramePoseTree.get_transform", "modulename": "posetree.pose", "qualname": "CustomFramePoseTree.get_transform", "kind": "function", "doc": "<p>Return the transform from the parent frame to the child frame, at the timestamp.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">parent_frame</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">child_frame</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">timestamp</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Transform</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Transform", "modulename": "posetree.pose", "qualname": "Transform", "kind": "class", "doc": "<p>A homogenous transform from a pose or frame to another location and rotation.</p>\n\n<p>In posetree, a Transform is a verb. It describes how to transform a pose from one frame to another.\nAlmost all the time, you want to turn your raw data objects (coming from forward kinematics or perception or \nlocalization) into a Pose object as soon as possible, and only go through Transforms at the borders of your sdk.</p>\n\n<p>Using Transform objects instead of Pose objects is usually a code smell, unless you're doing something really\nmathy with a bunch of intermediate transforms.</p>\n"}, {"fullname": "posetree.pose.Transform.__init__", "modulename": "posetree.pose", "qualname": "Transform.__init__", "kind": "function", "doc": "<p>Create a transform from a position and rotation.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>position:</strong>  The position of the transform.</li>\n<li><strong>rotation:</strong>  The rotation of the transform.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">position</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">rotation</span><span class=\"p\">:</span> <span class=\"n\">scipy</span><span class=\"o\">.</span><span class=\"n\">spatial</span><span class=\"o\">.</span><span class=\"n\">transform</span><span class=\"o\">.</span><span class=\"n\">_rotation</span><span class=\"o\">.</span><span class=\"n\">Rotation</span></span>)</span>"}, {"fullname": "posetree.pose.Transform.from_position_and_quaternion", "modulename": "posetree.pose", "qualname": "Transform.from_position_and_quaternion", "kind": "function", "doc": "<p>Create a transform from a position and quaternion.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>position:</strong>  The position of the transform.</li>\n<li><strong>quaternion:</strong>  The quaternion of the transform, in xyzw order.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new transform.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">position</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">quaternion</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Transform</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Transform.identity", "modulename": "posetree.pose", "qualname": "Transform.identity", "kind": "function", "doc": "<p>Return the identity transform.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Transform</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Transform.inverse", "modulename": "posetree.pose", "qualname": "Transform.inverse", "kind": "variable", "doc": "<p>The inverse of the transform.</p>\n\n<p>How to get back from applying this transform.</p>\n\n<p>t1 * t1.inverse == Transform.identity()</p>\n", "annotation": ": posetree.pose.Transform"}, {"fullname": "posetree.pose.Transform.position", "modulename": "posetree.pose", "qualname": "Transform.position", "kind": "variable", "doc": "<p>The 1x3 cartesian position of the transform.</p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "posetree.pose.Transform.rotation", "modulename": "posetree.pose", "qualname": "Transform.rotation", "kind": "variable", "doc": "<p>The rotation component of the transform.</p>\n", "annotation": ": scipy.spatial.transform._rotation.Rotation"}, {"fullname": "posetree.pose.Transform.x_axis", "modulename": "posetree.pose", "qualname": "Transform.x_axis", "kind": "variable", "doc": "<p>The x axis of the transform.</p>\n\n<p>This is the unit vector, in the parent frame, pointing in the new x direction, after applying the transform.</p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "posetree.pose.Transform.y_axis", "modulename": "posetree.pose", "qualname": "Transform.y_axis", "kind": "variable", "doc": "<p>The y axis of the transform.</p>\n\n<p>This is the unit vector, in the parent frame, pointing in the new y direction, after applying the transform.</p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "posetree.pose.Transform.z_axis", "modulename": "posetree.pose", "qualname": "Transform.z_axis", "kind": "variable", "doc": "<p>The z axis of the transform.</p>\n\n<p>This is the unit vector, in the parent frame, pointing in the new z direction, after applying the transform.</p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "posetree.pose.Transform.x", "modulename": "posetree.pose", "qualname": "Transform.x", "kind": "variable", "doc": "<p>The x coordinate of the transform.</p>\n", "annotation": ": float"}, {"fullname": "posetree.pose.Transform.y", "modulename": "posetree.pose", "qualname": "Transform.y", "kind": "variable", "doc": "<p>The y coordinate of the transform.</p>\n", "annotation": ": float"}, {"fullname": "posetree.pose.Transform.z", "modulename": "posetree.pose", "qualname": "Transform.z", "kind": "variable", "doc": "<p>The z coordinate of the transform.</p>\n", "annotation": ": float"}, {"fullname": "posetree.pose.Transform.to_matrix", "modulename": "posetree.pose", "qualname": "Transform.to_matrix", "kind": "function", "doc": "<p>Return the 4x4 matrix representation of the transform.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Transform.from_matrix", "modulename": "posetree.pose", "qualname": "Transform.from_matrix", "kind": "function", "doc": "<p>Create a transform from a matrix.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>matrix:</strong>  The matrix of the transform.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new transform.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">matrix</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Transform</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Transform.apply", "modulename": "posetree.pose", "qualname": "Transform.apply", "kind": "function", "doc": "<p>Multiply this transform by another transform or vector.</p>\n\n<p>If other is a transform, this is equivalent to applying this transform, then the other transform.\nIf other is a vector, this is equivalent to applying this transform to the vector.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>other:</strong>  The transform or vector to multiply.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The product of the two transforms.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">other</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Transform</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Transform</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Transform.almost_equal", "modulename": "posetree.pose", "qualname": "Transform.almost_equal", "kind": "function", "doc": "<p>Check if two transforms are almost equal.</p>\n\n<p>Handles floating point error in the position and rotation, and the fact that for quaternions negating \nthe vector gives the same rotation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span><span class=\"p\">:</span> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Transform</span>, </span><span class=\"param\"><span class=\"n\">atol</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-08</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Transform.interpolate", "modulename": "posetree.pose", "qualname": "Transform.interpolate", "kind": "function", "doc": "<p>Interpolate between two transforms.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>other:</strong>  The other transform to interpolate with.</li>\n<li><strong>alpha:</strong>  The interpolation factor. 0 gives this transform, 1 gives the other transform.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The interpolated transform.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">other</span><span class=\"p\">:</span> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Transform</span>,</span><span class=\"param\">\t<span class=\"n\">alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Transform</span>:</span></span>", "funcdef": "def"}, {"fullname": "posetree.pose.Transform.angle_to", "modulename": "posetree.pose", "qualname": "Transform.angle_to", "kind": "function", "doc": "<p>Return the angle between two transforms' orientations. Ignores position.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>target:</strong>  The target transform.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The angle between two transform, in radians.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">posetree</span><span class=\"o\">.</span><span class=\"n\">pose</span><span class=\"o\">.</span><span class=\"n\">Transform</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();